/*	File DocumentTableModel.java * ============================================================================= *  * A table model that is a vector of vectors of Documents (ManyMindsDocuments by * default). *  * Author Chris Schneider * Copyright © 1999 University of California * All Rights Reserved. *  * Agenda *  * History * 04 Nov 99	CSS	Broke out from ArtifactApplet.java. * 28 FEB 00	EME	Added clone mechanism and set default to ManyMindsDocument *  * ============================================================================= *//*  Copyright (C) 1998-2002 Regents of the University of California *  This file is part of ManyMinds. * *  ManyMinds is free software; you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation; either version 2 of the License, or *  (at your option) any later version. *   *  ManyMinds is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. *   *  You should have received a copy of the GNU General Public License *  along with ManyMinds; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */ package manyminds.datamodel;import java.io.Serializable;import java.util.Vector;import javax.swing.event.DocumentEvent;import javax.swing.event.DocumentListener;import javax.swing.event.TableModelEvent;import javax.swing.table.DefaultTableModel;import javax.swing.text.Document;/** * A table model that is a vector of vectors of Documents (PlainDocuments by * default). *  * @author	Chris Schneider */publicclass DocumentTableModel extends DefaultTableModel	implements DocumentListener, Serializable{	/**	 * creates a new table model containing text documents	 */	public	DocumentTableModel()	{		super();			} // DocumentTableModel	/**	 * creates a new table model containing text documents	 *	 *	@param	rows		number of rows in table	 *	@param	columns	number of columns in table	 */	public	DocumentTableModel(int numRows, int numColumns)	{		super(numRows, numColumns);			} // DocumentTableModel	/**	 * creates a new table model containing text documents	 *	 *	@param	columnNames	names appearing above columns in table	 *	@param	rows			number of rows in table	 */	public	DocumentTableModel(	Vector			columnNames,								int				numRows)	{		super(columnNames, numRows);			} // DocumentTableModel	/**	 * creates a new table model containing text documents	 *	 *	@param	columnNames	names appearing above columns in table	 *	@param	rows			number of rows in table	 */	public	DocumentTableModel(	Object[]			columnNames,								int				numRows)	{		super(columnNames, numRows);			} // DocumentTableModel	/**	 * creates a new table model containing text documents	 *	 *	@param	data			vector of vectors of cell Documents	 *	@param	columnNames	names appearing above columns in table	 */	public	DocumentTableModel(	Vector			data,								Vector			columnNames)	{		super(data, columnNames);			} // DocumentTableModel	/**	 * creates a new table model containing text documents	 *	 *	@param	data			array of arrays of cell Documents	 *	@param	columnNames	names appearing above columns in table	 */	public	DocumentTableModel(	Object[][]		data,								Object[]			columnNames)	{		super(data, columnNames);			} // DocumentTableModel	/**	 * changes the number of rows in the table	 *	 *	@param	newNumRows	number of rows desired	 */	public void	setNumRows(				int				newNumRows)	{		int				oldNumRows = getRowCount();		int				numColumns = getColumnCount();				if (newNumRows > oldNumRows) {					/* Create the new rows with empty vectors			*/			for (	int				newRowIndex = oldNumRows;					newRowIndex < newNumRows;					newRowIndex++) {            getDataVector().addElement(new Vector(numColumns));			}			/* Generate notification, but make sure the new rows all have the			right number of Documents (columns) first			*/			newRowsAdded(new TableModelEvent(this,        												oldNumRows,        												getRowCount()-1,                             					TableModelEvent.ALL_COLUMNS,                             					TableModelEvent.INSERT));		} else {			super.setNumRows(newNumRows);		}	} // setNumRows		/**	 * notifies listeners that new rows were added, but also ensures that these	 *	rows have the right number of Documents (columns) first	 *	 *	@param	event	describes the change in the number of rows	 */	public void	newRowsAdded(			TableModelEvent event)	{		int				firstNewRowIndex = event.getFirstRow();		int				lastNewRowIndex = event.getLastRow();		int				numColumns = getColumnCount();				/* Bounds check new row range		*/		if (firstNewRowIndex < 0)			firstNewRowIndex = 0;		if (lastNewRowIndex < 0)			lastNewRowIndex = getRowCount()-1;		/* Make sure all the new rows have the correct number of Documents		*/		for (	int				newRowIndex = firstNewRowIndex;				newRowIndex <= lastNewRowIndex;				newRowIndex++) {			Vector			rowVector = (Vector)dataVector.elementAt(newRowIndex);						if (rowVector.size() > numColumns) {				rowVector.setSize(numColumns);			} else {				for (	int				columnIndex = rowVector.size();						columnIndex < numColumns;						columnIndex++) {					rowVector.addElement(ManyMindsDocument.newDocument());				}			}		}		/* Finally, notify listeners		*/		fireTableChanged(event);        	} // newRowsAdded		/**	 * retrieve the Document associated with a particular table cell	 *	 *	@param	row		index of target cell row	 *	@param	column	index of target cell column	 *	 *	@return	Document in target cell, rather than its contents	 */	public Document	getDocumentAt(			int				row,								int				column)	{		return((Document)super.getValueAt(row, column));			} // getDocumentAt		/**	 * retrieve the contents of the Document associated with a particular	 *	table cell	 *	 *	@param	row		index of target cell row	 *	@param	column	index of target cell column	 *	 *	@return	Document text from target cell, rather than Document itself	 */	public Object	getValueAt(				int				row,								int				column)	{		Document			cellDocument = getDocumentAt(row, column);		Object			returnValue = null;				if (cellDocument != null) {			try {				returnValue = cellDocument.getText(0, cellDocument.getLength());			} catch (Exception e) {			}		}		return(returnValue);			} // getValueAt		/**	 * set the contents of the Document associated with a particular	 *	table cell	 *	 *	@param	row		index of target cell row	 *	@param	column	index of target cell column	 *	@param	aValue	text to place into Document in target cell	 */	public void	setValueAt(				Object			aValue,								int				row,								int				column)	{		Document			cellDocument = getDocumentAt(row, column);				try {			cellDocument.remove(0, cellDocument.getLength());			cellDocument.insertString(0, (String)aValue, null);		} catch (Exception e) {		}	} // setValueAt		/**	 * responds to a change in the contents of a Document in one of the cells	 *	by informing the table that the cell changed	 *	 *	@param	event	describes the text change in the cell's Document	 */	public void	changedUpdate(			DocumentEvent	event)	{		cellDocumentUpdate(event);			} // changeUpdate		/**	 * responds to text being inserted into the Document in one of the cells	 *	by informing the table that the cell changed	 *	 *	@param	event	describing the text insertion into the cell's Document	 */	public void	insertUpdate(			DocumentEvent	event)	{		cellDocumentUpdate(event);			} // insertUpdate		/**	 * responds to text being deleted from the Document in one of the cells	 *	by informing the table that the cell changed	 *	 *	@param	event	describing the text removal from the cell's Document	 */	public void	removeUpdate(			DocumentEvent	event)	{		cellDocumentUpdate(event);			} // removeUpdate		/**	 * responds to any change in the contents of a Document in one of the cells	 *	by informing the table that the cell changed	 *	 *	@param	event	describes the text change in the cell's Document	 */	protected void	cellDocumentUpdate(	DocumentEvent	event)	{		int				numRows = getRowCount();		int				numColumns = getColumnCount();		Document			dirtyDocument = event.getDocument();				for (	int				rowIndex = 0;				rowIndex < numRows;				rowIndex++) {			for (	int				columnIndex = 0;					columnIndex < numColumns;					columnIndex++) {				if (getDocumentAt(rowIndex, columnIndex) == dirtyDocument) {					fireTableCellUpdated(rowIndex, columnIndex);				}			}		}	} // cellDocumentUpdate	} // DocumentTableModel