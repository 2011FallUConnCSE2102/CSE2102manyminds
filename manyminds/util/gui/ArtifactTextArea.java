/*	File ArtifactTextArea.java * ============================================================================= *  * A text area within some page in the current ManyMinds Artifact. *  * Author Chris Schneider * Copyright © 1999 University of California * All Rights Reserved. *  * Agenda *  * History * 11 Nov 99	CSS	New today (from ArtifactPane.java). *	15 Dec 99	CSS	Overrode get/setToolTipText methods to reference JTextArea *							inside.  This is probably just the first of an infinite *							number of such overrides.  I should probably handle this *							some other way. *	17 Dec 99	CSS	Changed name from ArtifactScrollTextArea to ArtifactTextArea, *							based it on JTextArea, implemented OrientedScrollable, and *							removed the tool tip methods. *  * ============================================================================= *//*  Copyright (C) 1998-2002 Regents of the University of California *  This file is part of ManyMinds. * *  ManyMinds is free software; you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation; either version 2 of the License, or *  (at your option) any later version. *   *  ManyMinds is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. *   *  You should have received a copy of the GNU General Public License *  along with ManyMinds; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */ package manyminds.util.gui;import java.awt.Font;import javax.swing.JTextArea;import javax.swing.ScrollPaneConstants;import javax.swing.text.Document;import manyminds.ManyMindsConstants;/** * A text area within some page in the current ManyMinds Artifact. *  * @author	Chris Schneider */publicclass ArtifactTextArea extends JTextAreaimplements OrientedScrollable, ManyMindsConstants {        /*protected boolean realTimeChecking = false;    protected Object spellingDriver = null;    protected static java.util.List allTextAreas = new java.util.ArrayList();*/        private void    setupTextArea() {        setLineWrap(true);        setWrapStyleWord(true);        Font f = getFont();       // setFont(f.deriveFont(Font.PLAIN,(float)14.0));//        allTextAreas.add(new WeakReference(this));    }       /* protected synchronized Object    getSpellingDriver() {        try {            Class driverClass = java.lang.Class.forName("com.apple.spell.ui.JTextComponentDriver");            if (spellingDriver == null) {                spellingDriver = driverClass.newInstance();            }        } catch (Throwable t) {            t.printStackTrace();        }        return spellingDriver;    }*/    public    ArtifactTextArea(Document doc, String text, int rows, int columns) {        super(doc, text, rows, columns);        setupTextArea();    } // ArtifactTextArea        public    ArtifactTextArea(int rows, int columns) {        super(rows, columns);        setupTextArea();    } // ArtifactTextArea        /**        * creates a text area that wraps text in the expected (rather        *	than default) manner        *        * @param	doc		data model underneath text area        *	@param	text		initial contents        *	@param	rows		height of text area in characters        *	@param	columns	width of text area in characters        */        public    ArtifactTextArea(Document doc) {        super(doc);        setupTextArea();    } // ArtifactTextArea        /**        * returns what component wants to do about horizontal scrolling        *        *	@returns	when/whether horizontal scrolling should be allowed        */    public int    getHorizontalScrollBarPolicy() {        return(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);    } // getHorizontalScrollBarPolicy        /**        * returns what component wants to do about vertical scrolling        *        *	@returns	when/whether vertical scrolling should be allowed        */    public int    getVerticalScrollBarPolicy() {        return(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);    } // getVerticalScrollBarPolicy          /*  public void    checkSpelling() {        try {            Class driverClass = java.lang.Class.forName("com.apple.spell.ui.JTextComponentDriver");            Method checkMethod = driverClass.getMethod("checkSpelling", new Class[]{manyminds.util.gui.ArtifactTextArea.class});            checkMethod.invoke(getSpellingDriver(), new Object[]{this});        } catch (Throwable t) {            t.printStackTrace();        }    }        public static void    setAllRealtimeSpellcheck(boolean c) {        for (int i = allTextAreas.size()-1; i >= 0; --i) {            WeakReference we = (WeakReference)allTextAreas.get(i);            Object o = we.get();            if (o != null) {                ((ArtifactTextArea)o).setRealtimeSpellcheck(c);            } else {                allTextAreas.remove(i);            }        }    }                public void    setRealtimeSpellcheck(boolean c) {        if (c) {            System.err.println("turning on!");            try {                Class driverClass = java.lang.Class.forName("com.apple.spell.ui.JTextComponentDriver");                Method checkMethod = driverClass.getMethod("startRealtimeChecking",new Class[]{javax.swing.text.JTextComponent.class});                checkMethod.invoke(getSpellingDriver(), new Object[]{this});            } catch (Throwable t) {                t.printStackTrace();            }        } else {            System.err.println("turning off!");            try {                Class driverClass = java.lang.Class.forName("com.apple.spell.ui.JTextComponentDriver");                Method checkMethod = driverClass.getMethod("stopRealtimeChecking",null);                checkMethod.invoke(getSpellingDriver(), null);            } catch (Throwable t) {                t.printStackTrace();            }        }        realTimeChecking = c;    }        public void    toggleRealtimeSpellcheck() {        setRealtimeSpellcheck(realTimeChecking ^ true);    }*/} // ArtifactTextArea